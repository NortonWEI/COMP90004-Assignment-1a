# Author: Wenzhou Wei (903836)

The system simulates the entire operation process of multiple pilots from acquiring to releasing their ships around USS Emafor. The simulative model adopts multithreading techniques so that multiple pilots are able to work concurrently, while the producer and the consumer should allocate and deallocate ships according to the status of wait zones. There are various constraints (e.g. the number of tugs, the activation of the shield, etc.) on the system, resulting in various locks involved thereof. Hence, some potential problems and insights are discovered based on my observation of the system.

For simplicity, I assume that the capacities of arrival zone and departure zone are both 1. However, if more capacity is further required, it is also possible to upgrade the system by maintaining a list of ships in wait zones, yet the main idea does not change much. The producer should be locked when its list is full, while unlocked otherwise.  The producer should be locked when its list is full, while unlocked otherwise. Similarly, the consumer should be locked when its list is empty, while unlocked otherwise.

The normal operation of this system depends highly on the resources available, namely the number of tugs remaining. If the total number of tugs is a multiple of docking tugs or the remaining tugs after docking acquirement are still less than a single undocking requiring, a deadlock is highly likely to arise in the system. Mathematically, say the numbers of total tugs, docking tugs and undocking tugs are N, D, U, respectively. Let R = N mod D. If R < U, then a deadlock is fairly possible to happen. Intuitively, since all the ships acquired by their pilots have been appended with docking tugs, when there is a ship finishing unloading at the berth, no enough undocking tugs are available for undocking operation. That is, the ship at the berth is waiting for the ship to be docked to release tugs, while the latter is waiting for the former to undock. Therefore, a deadlock occurs. Specially, if there is only 1 pilot existing in the system, the program becomes serial so that the deadlock will never happen.

Since all the critical functions are synchronized, the program fulfils mutual exclusion (i.e. only 1 pilot is able to modify shared data at a time). Moreover, if the total number of docking tugs required is less than or equal to the total number of tugs (i.e. NUM_PILOTS * DOCKING_TUGS <= NUM_TUGS), the pilot threads should not be starved. Otherwise, the idle pilots may forever wait for ships coming (but they will not). All the threads are properly locked and unlocked under certain conditions, so there is no racing condition either.

A significant difficulty encountered was I used “notify()” instead of “notifyAll()” in my “synchronized void departFromArrivalZone(Pilot pilot)” function. A deadlock arose when I try to notify the producer thread that a ship has departed from arrival zone. However, when I change it to notifyAll() from notify(), the deadlock disappeared. It is because I awoke all of the threads waiting rather than one.

The project provides me with an opportunity to get a better understanding of modelling a concurrent complex system using Java.
